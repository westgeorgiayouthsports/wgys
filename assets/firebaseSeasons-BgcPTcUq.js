import{n as u,o as l,z as D,x,q as b}from"./vendor-firebase-BzUsRx-X.js";import{e as h,q as S,A as v,l as d}from"./index-lWfxYzVq.js";import{S as T,a as f}from"./season-CjhZh6iC.js";import{p as A}from"./firebasePrograms-DQfL_YhU.js";import{t as B}from"./firebaseTeams-DYGNnM-E.js";import{s as C}from"./slugify-IzZIKjBC.js";const P={deriveSeasonMeta(e){try{const t=(e||"").match(/^(\d{4})-(\d{2})-(\d{2})$/);let a;if(t){const w=Number(t[1]),i=Number(t[2]),p=Number(t[3]);a=new Date(w,i-1,p)}else a=new Date(e);const r=a.getMonth()+1,o=a.getFullYear();let s;return r>=3&&r<=5?s=f.spring:r>=6&&r<=8?s=f.summer:r>=9&&r<=11?s=f.fall:s=f.winter,{type:s,year:o}}catch(t){return d.error("Error deriving season meta from startDate: ",t),{type:f.spring,year:new Date().getFullYear()}}},async getSeasons(){try{const e=await u(l(h,"seasons"));if(!e.exists())return[];const t=e.val();return t?Object.entries(t).map(([a,r])=>({id:a,...r})):[]}catch(e){return d.error("Error fetching seasons:",e),[]}},async archiveSeasonCascade(e,t){const a=new Date().toISOString();await x(l(h,`seasons/${e}`),{status:T.archived,updatedAt:a,archivedAt:a});const r=await A.getProgramsBySeason(e);for(const o of r){const s=l(h,`programs/${o.id}`);await x(s,{active:!1,status:"archived",updatedAt:a,archivedAt:a});const w=await B.getTeamsByProgram(o.id);for(const i of w)await B.updateTeam(i.id,{status:"archived",updatedAt:a})}try{await S.log({action:"season.archive_cascade",entityType:v.Season,entityId:e,actorId:t??void 0,details:{programCount:r.length,teamCount:r.reduce((o,s)=>o+(s.currentRegistrants,0),0)}})}catch(o){d.error("Error auditing season.archive_cascade:",o)}},async getActiveSeasons(){try{return(await this.getSeasons()).filter(t=>t.status===T.active)}catch(e){throw d.error("Error fetching active seasons:",e),e}},async getSeasonById(e){try{const t=await u(l(h,`seasons/${e}`));return t.exists()?{id:e,...t.val()}:null}catch(t){throw d.error("Error fetching season:",t),t}},async createSeason(e,t){try{const a=await this.getSeasons(),r=(e.name||"").trim().toLowerCase();if(r&&a.find(m=>(m.name||"").trim().toLowerCase()===r))throw new Error("A season with that name already exists");let o,s;if(e.startDate){const c=this.deriveSeasonMeta(e.startDate);o=c.type,s=c.year}else e.seasonType&&e.year&&(o=e.seasonType,s=e.year);if(o&&s&&a.find(m=>m.seasonType===o&&m.year===s))throw new Error("A season with that type and year already exists");const w=new Date().toISOString();let i,p;if(o&&s){const c=C(`${s}-${o}`);if((await u(l(h,`seasons/${c}`))).exists()){let E=1,$=`${c}-${E}`;for(;(await u(l(h,`seasons/${$}`))).exists();)E+=1,$=`${c}-${E}`;i=$}else i=c;p=l(h,`seasons/${i}`)}else p=l(h,`seasons/${Date.now()}`),i=p.key;const n=Object.fromEntries(Object.entries(e).filter(([c,m])=>m!==void 0&&m!==""));let y={};if(n.startDate){const c=this.deriveSeasonMeta(n.startDate);y.seasonType=c.type,y.year=c.year}const g={...n,...y,status:n.status||T.active,createdAt:w,updatedAt:w,createdBy:t};await b(p,g);try{await S.log({action:"season.created",entityType:v.Season,entityId:i,details:{id:i,...g}})}catch(c){d.error("Error auditing season.created:",c)}return i}catch(a){throw d.error("Error creating season:",a),a}},async updateSeason(e,t,a){try{const r=await this.getSeasons();if(t.name){const n=(t.name||"").trim().toLowerCase();if(r.find(g=>g.id!==e&&(g.name||"").trim().toLowerCase()===n))throw new Error("A season with that name already exists")}let o,s;if(t.startDate){const n=this.deriveSeasonMeta(t.startDate);o=n.type,s=n.year}else if(t.seasonType&&t.year)o=t.seasonType,s=t.year;else{const n=await this.getSeasonById(e);n&&(o=t.seasonType??n.seasonType,s=t.year??n.year)}if(o&&s&&r.find(y=>y.id!==e&&y.seasonType===o&&y.year===s))throw new Error("A season with that type and year already exists");const w=l(h,`seasons/${e}`),i=Object.fromEntries(Object.entries(t).filter(([n,y])=>y!==void 0&&y!=="")),p={...i,updatedAt:new Date().toISOString()};if(i.startDate){const n=this.deriveSeasonMeta(i.startDate);p.seasonType=n.type,p.year=n.year}await x(w,p);try{await S.log({action:"season.updated",entityType:v.Season,entityId:e,actorId:a??void 0,details:i})}catch(n){d.error("Error auditing season.updated:",n)}}catch(r){throw d.error("Error updating season:",r),r}},async archiveSeason(e){try{await this.updateSeason(e,{status:T.archived})}catch(t){throw d.error("Error archiving season:",t),t}},async deleteSeason(e,t){try{const a=await A.getProgramsBySeason(e);if(a&&a.length>0)throw new Error("Cannot delete season: programs are still linked to this season");const r=await u(l(h,`seasons/${e}`)),o=r.exists()?r.val():null;await D(l(h,`seasons/${e}`));try{await S.logDelete(v.Season,e,o,t??void 0)}catch(s){d.error("Error auditing season.delete:",s)}}catch(a){throw d.error("Error deleting season:",a),a}}};export{P as s};
