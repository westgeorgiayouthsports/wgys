import{o as n,x as c,n as y,t as m,q as g,z as w}from"./vendor-firebase-BzUsRx-X.js";import{e as s,q as u,A as f,l}from"./index-lWfxYzVq.js";const P={async createPerson(t,e){const a=n(s,"people"),o=m(a),r=Object.fromEntries(Object.entries(t).filter(([p,d])=>d!==void 0)),i={...r,roles:r.roles||[],hasAccount:!1,relationships:[],contactPreferences:[],programs:[],teams:[],groups:t.groups||[],source:"manual",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),createdBy:e,isActive:!0};await c(o,i);try{await u.log({action:"person.created",entityType:f.Person,entityId:o.key,details:i})}catch(p){l.error("Error auditing person.created:",p)}return o.key},async getPeople(){const t=n(s,"people"),e=await y(t);if(!e.exists())return[];const a=e.val();return Object.entries(a).map(([o,r])=>({id:o,...r,roles:r.roles||[]}))},async getPersonById(t){const e=n(s,`people/${t}`),a=await y(e);if(!a.exists())return null;const o=a.val();return{id:t,...o,roles:o.roles||[]}},async updatePerson(t,e){const a=n(s,`people/${t}`),o=Object.fromEntries(Object.entries(e).filter(([r,i])=>i!==void 0));await c(a,{...o,updatedAt:new Date().toISOString()});try{await u.log({action:"person.updated",entityType:f.Person,entityId:t,details:o})}catch(r){l.error("Error auditing person.updated:",r)}},async deletePerson(t){try{const e=n(s,`people/${t}`),a=await y(e),o=a.exists()?a.val():null;await w(e);try{await u.logDelete(f.Person,t,o)}catch(r){l.error("Error auditing person.delete:",r)}}catch(e){throw l.error("Error deleting person:",e),e}},async linkPersonToAccount(t,e){const a=n(s,`people/${t}`);await c(a,{hasAccount:!0,userId:e,updatedAt:new Date().toISOString()});try{const o=n(s,`users_to_person/${e}`);await g(o,t)}catch(o){l.error("Failed to write users_to_person mapping:",o)}},async createFamily(t,e,a){const o=n(s,"families"),r=m(o),i={name:t,primaryPersonId:e,memberIds:[e],createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),createdBy:a};await c(r,i);try{await u.log({action:"family.created",entityType:f.Family,entityId:r.key,details:i})}catch(d){l.error("Error auditing family.created:",d)}const p=n(s,`people/${e}`);return await c(p,{familyId:r.key,updatedAt:new Date().toISOString()}),r.key},async getFamilies(){const t=n(s,"families"),e=await y(t);if(!e.exists())return[];const a=e.val();return Object.entries(a).map(([o,r])=>({id:o,...r}))},async addPersonToFamily(t,e){const a=n(s,`families/${t}`),o=await y(a);if(o.exists()){const i=[...o.val().memberIds||[],e];await c(a,{memberIds:i,updatedAt:new Date().toISOString()});const p=n(s,`people/${e}`);await c(p,{familyId:t,updatedAt:new Date().toISOString()});try{await u.log({action:"family.member_added",entityType:f.Family,entityId:t,details:{memberId:e}})}catch(d){l.error("Error auditing family.member_added:",d)}}},async getPeopleByRole(t){return(await this.getPeople()).filter(a=>(a.roles||[]).includes(t))},async getPeopleWithAccounts(){return(await this.getPeople()).filter(e=>e.hasAccount)},async getPeopleByFamily(t){return(await this.getPeople()).filter(a=>a.familyId===t)},async updatePersonProfile(t,e){const a=n(s,`people/${t}`);await c(a,{...e,updatedAt:new Date().toISOString()})},async getPersonByUserId(t){return(await this.getPeople()).find(a=>a.userId===t)||null}};export{P as p};
