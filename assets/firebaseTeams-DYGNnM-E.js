import{o as m,A as g,B as p,N as w,n as h,z as E,x as T,t as I,q as b}from"./vendor-firebase-BzUsRx-X.js";import{e as d,l as n,q as y,A as f,p as v}from"./index-lWfxYzVq.js";const A={async getTeams(){try{const e=m(d,"teams"),t=await h(e);if(!t.exists())return[];const r=t.val();return Object.entries(r).map(([a,s])=>{const{id:c,...o}=s;return{id:a,...o}})}catch(e){throw n.error("Error fetching teams:",e),e}},async getUserTeams(e){try{const t=m(d,"teams"),r=await h(t);if(!r.exists())return[];const a=r.val();return Object.entries(a).map(([s,c])=>{const{id:o,...i}=c;return{id:s,...i}})}catch(t){throw n.error("Error fetching teams:",t),t}},async createTeam(e){try{const t=m(d,"teams"),r=I(t),a=v.currentUser?.uid;if(!a)throw new Error("User must be authenticated to create a team");const{coachId:s,...c}=e,o={...c,...s&&{coachId:s},userId:a,id:r.key,createdAt:new Date().toISOString()},i={};Object.entries(o).forEach(([u,l])=>{l!==void 0&&(i[u]=l)}),await b(r,i);try{await y.log({action:"team.created",entityType:f.Team,entityId:r.key,details:o})}catch(u){n.error("Error auditing team.created:",u)}return o}catch(t){throw n.error("Error creating team:",t),t}},async updateTeam(e,t){try{if(!e)throw new Error("Team ID is required");const{id:r,createdAt:a,...s}=t,c=m(d,`teams/${e}`),o={};Object.entries(s).forEach(([i,u])=>{u!==void 0&&(o[i]=u)}),o.updatedAt=new Date().toISOString(),await T(c,o);try{await y.log({action:"team.updated",entityType:f.Team,entityId:e,details:s})}catch(i){n.error("Error auditing team.updated:",i)}}catch(r){throw n.error("Error updating team:",r),r}},async deleteTeam(e){try{const t=m(d,`teams/${e}`),r=await h(t),a=r.exists()?r.val():null;await E(t);try{await y.logDelete(f.Team,e,a)}catch(s){n.error("Error auditing team.delete:",s)}}catch(t){throw n.error("Error deleting team:",t),t}},async getTeamById(e){try{if(!e)return null;const t=m(d,`teams/${e}`),r=await h(t);if(!r.exists())return null;const a=r.val();return{id:e,...a}}catch(t){throw n.error("Error fetching team:",t),t}},async getTeamsByProgram(e){try{const t=m(d,"teams"),r=g(t,p("programId"),w(e)),a=await h(r);if(!a.exists())return[];const s=a.val();return Object.entries(s).map(([c,o])=>({id:c,...o}))}catch(t){throw n.error("Error fetching teams by program:",t),t}}};export{A as t};
